<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      canvas {
        background: #eee;
        display: block;
        margin: 0 auto;
        padding: 80px 0 0 120px;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="1200"></canvas>
    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // 타일 크기 설정
      const TILE_SIZE = 60;

      // 맵 데이터 배열 (0: 빈공간, 1: 잔디, 2: 회색블록, 3: 갈색블록, 4: 빨간팀, 5: 파란팀, 6: 중앙박스)
      const mapData = [
        [0, 1, 0, 0, 4, 4, 4, 0, 0, 1, 0],
        [0, 0, 0, 0, 7, 0, 7, 1, 0, 0, 0],
        [1, 1, 2, 2, 0, 7, 0, 3, 3, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 2, 0, 3, 3, 0, 0, 1],
        [1, 0, 0, 1, 0, 6, 0, 1, 0, 0, 1],
        [1, 0, 0, 3, 3, 0, 2, 2, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
        [1, 3, 3, 0, 0, 8, 0, 2, 2, 1, 0],
        [0, 0, 1, 0, 8, 0, 8, 0, 2, 0, 0],
        [1, 0, 0, 0, 5, 5, 5, 0, 0, 0, 1],
      ];

      function drawMap() {
        mapData.forEach((row, y) => {
          row.forEach((tile, x) => {
            const posX = x * TILE_SIZE;
            const posY = y * TILE_SIZE;

            // 기본 배경
            ctx.fillStyle = "#FFC088"; // 살구색 배경
            ctx.fillRect(posX, posY, TILE_SIZE, TILE_SIZE);

            switch (tile) {
              case 1: // 잔디
                // 기본 잔디 색상 배경
                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(posX, posY, TILE_SIZE, TILE_SIZE);

                // 잔디 패턴 추가
                ctx.strokeStyle = "#388E3C"; // 더 어두운 녹색
                ctx.lineWidth = 8;

                // 격자 형태로 짧은 선들을 그림
                for (let i = 0; i < 3; i++) {
                  for (let j = 0; j < 3; j++) {
                    const x = posX + (TILE_SIZE / 3) * i + 10;
                    const y = posY + (TILE_SIZE / 3) * j + 10;

                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + 5);
                    ctx.stroke();
                  }
                }
                break;
              case 2: // 회색 블록
                // 기본 회색 배경
                ctx.fillStyle = "#9E9E9E";
                ctx.fillRect(posX, posY, TILE_SIZE, TILE_SIZE);

                // X자 그리기
                ctx.strokeStyle = "#757575"; // 더 어두운 회색
                ctx.lineWidth = 4;

                // 왼쪽 상단에서 오른쪽 하단으로
                ctx.beginPath();
                ctx.moveTo(posX + 10, posY + 10);
                ctx.lineTo(posX + TILE_SIZE - 10, posY + TILE_SIZE - 10);
                ctx.stroke();

                // 오른쪽 상단에서 왼쪽 하단으로
                ctx.beginPath();
                ctx.moveTo(posX + TILE_SIZE - 10, posY + 10);
                ctx.lineTo(posX + 10, posY + TILE_SIZE - 10);
                ctx.stroke();
                break;
              case 3: // 갈색 블록 (나무)
                // 기본 나무 색상 배경
                ctx.fillStyle = "#8D6E63";
                ctx.fillRect(posX, posY, TILE_SIZE, TILE_SIZE);

                // 나무 결 패턴
                ctx.strokeStyle = "#6D4C41"; // 더 어두운 갈색
                ctx.lineWidth = 3;

                // 세로 방향 나무 결 그리기
                for (let i = 1; i <= 3; i++) {
                  const x = posX + (TILE_SIZE / 4) * i;

                  ctx.beginPath();
                  ctx.moveTo(x, posY + 5);
                  ctx.lineTo(x, posY + TILE_SIZE - 5);
                  ctx.stroke();
                }

                // 가로 방향 마디 그리기 (2개)
                for (let i = 1; i <= 2; i++) {
                  const y = posY + (TILE_SIZE / 3) * i;

                  ctx.beginPath();
                  ctx.moveTo(posX + 5, y);
                  ctx.lineTo(posX + TILE_SIZE - 5, y);
                  ctx.stroke();
                }
                break;
              case 4: // 빨간팀
                ctx.beginPath();
                ctx.arc(
                  posX + TILE_SIZE / 2,
                  posY + TILE_SIZE / 2,
                  TILE_SIZE / 3,
                  0,
                  Math.PI * 2
                );
                ctx.fillStyle = "rgba(33, 150, 243, 0.3)";
                ctx.fill();
                ctx.strokeStyle = "#F44336";
                ctx.lineWidth = 4;
                ctx.stroke();
                break;
              case 5: // 파란팀
                ctx.beginPath();
                ctx.arc(
                  posX + TILE_SIZE / 2,
                  posY + TILE_SIZE / 2,
                  TILE_SIZE / 3,
                  0,
                  Math.PI * 2
                );
                ctx.fillStyle = "rgba(33, 150, 243, 0.3)";
                ctx.fill();
                ctx.strokeStyle = "#2196F3";
                ctx.lineWidth = 4;
                ctx.stroke();
                break;
              case 6: // 중앙 박스
                ctx.fillStyle = "#795548";
                ctx.fillRect(
                  posX + TILE_SIZE / 4,
                  posY + TILE_SIZE / 4,
                  TILE_SIZE / 2,
                  TILE_SIZE / 2
                );
                break;
              case 7: // 빨간옷 사람
                // 몸통
                ctx.fillStyle = "#F44336"; // 빨간색
                ctx.fillRect(
                  posX + TILE_SIZE / 4,
                  posY + TILE_SIZE / 3,
                  TILE_SIZE / 2,
                  TILE_SIZE / 2
                );

                // 머리
                ctx.beginPath();
                ctx.arc(
                  posX + TILE_SIZE / 2,
                  posY + TILE_SIZE / 4,
                  TILE_SIZE / 6,
                  0,
                  Math.PI * 2
                );
                ctx.fillStyle = "#FFE0B2"; // 살색
                ctx.fill();
                break;

              case 8: // 파란옷 사람
                // 몸통
                ctx.fillStyle = "#2196F3"; // 파란색
                ctx.fillRect(
                  posX + TILE_SIZE / 4,
                  posY + TILE_SIZE / 3,
                  TILE_SIZE / 2,
                  TILE_SIZE / 2
                );

                // 머리
                ctx.beginPath();
                ctx.arc(
                  posX + TILE_SIZE / 2,
                  posY + TILE_SIZE / 4,
                  TILE_SIZE / 6,
                  0,
                  Math.PI * 2
                );
                ctx.fillStyle = "#FFE0B2"; // 살색
                ctx.fill();
                break;
            }
          });
        });
      }

      // 플레이어 위치 추적을 위한 변수 추가
      const players = {
        red: { x: 0, y: 0 },
        blue: { x: 0, y: 0 },
      };

      // 초기 플레이어 위치 찾기
      function findPlayers() {
        mapData.forEach((row, y) => {
          row.forEach((tile, x) => {
            if (tile === 7) players.red = { x, y };
            if (tile === 8) players.blue = { x, y };
          });
        });
      }

      // 플레이어 이동 함수
      function movePlayer(player, dx, dy) {
        const p = player === "red" ? players.red : players.blue;
        const tileType = player === "red" ? 7 : 8;

        const newX = p.x + dx;
        const newY = p.y + dy;

        // 맵 범위 체크
        if (
          newX < 0 ||
          newX >= mapData[0].length ||
          newY < 0 ||
          newY >= mapData.length
        )
          return;

        // 이동 가능한 타일인지 체크 (0은 빈 공간)
        if (mapData[newY][newX] === 0) {
          mapData[p.y][p.x] = 0; // 이전 위치를 비움
          mapData[newY][newX] = tileType; // 새 위치로 이동
          p.x = newX;
          p.y = newY;
          drawMap(); // 맵 다시 그리기
        }
      }

      // 키보드 이벤트 처리
      document.addEventListener("keydown", (e) => {
        switch (e.key) {
          // 빨간 플레이어 (WASD)
          case "w":
            movePlayer("red", 0, -1);
            break;
          case "s":
            movePlayer("red", 0, 1);
            break;
          case "a":
            movePlayer("red", -1, 0);
            break;
          case "d":
            movePlayer("red", 1, 0);
            break;

          // 파란 플레이어 (화살표키)
          case "ArrowUp":
            movePlayer("blue", 0, -1);
            break;
          case "ArrowDown":
            movePlayer("blue", 0, 1);
            break;
          case "ArrowLeft":
            movePlayer("blue", -1, 0);
            break;
          case "ArrowRight":
            movePlayer("blue", 1, 0);
            break;
        }
        ㅈ;
      });

      // 초기 플레이어 위치 찾기
      findPlayers();

      // 맵 그리기
      drawMap();
    </script>
  </body>
</html>
